<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple OBJ Viewer</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        #container { 
            width: 100%; 
            height: 100vh; 
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }
        #file-input { 
            display: none; 
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">OBJ File Viewer</div>
    <div id="controls">
        <input type="file" id="file-input" accept=".obj">
        <button id="load-button">Load OBJ File</button>
        <button id="reset-button">Reset Camera</button>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.153.0/three.min.js"></script>
    <script>
        // Create main components
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        // Global variables
        let controls;
        let currentModel = null;
        
        // Setup renderer
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x333333);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Setup camera
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);
        
        // Add grid for reference
        const grid = new THREE.GridHelper(20, 20);
        scene.add(grid);
        
        // Create an origin marker (red, green, blue axes)
        const axesHelper = new THREE.AxesHelper(2);
        scene.add(axesHelper);
        
        // Add lights
        addLights();
        
        // Setup manual orbit controls
        setupOrbitControls();
        
        // Event listeners
        window.addEventListener('resize', onWindowResize);
        document.getElementById('load-button').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });
        document.getElementById('file-input').addEventListener('change', loadOBJFile);
        document.getElementById('reset-button').addEventListener('click', resetCamera);
        
        // Start animation loop
        animate();
        
        // Add lights to the scene
        function addLights() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            // Directional light (sun-like)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            
            // Point light
            const pointLight = new THREE.PointLight(0xff9900, 1, 50);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);
        }
        
        // Simple manual orbit control implementation
        function setupOrbitControls() {
            // Control state
            controls = {
                target: new THREE.Vector3(0, 0, 0),
                rotateSpeed: 1.0,
                zoomSpeed: 1.2,
                isDragging: false,
                previousMousePosition: { x: 0, y: 0 },
                update: function() {
                    // Make camera look at target
                    camera.lookAt(this.target);
                }
            };
            
            // Mouse events for rotation
            renderer.domElement.addEventListener('mousedown', (e) => {
                controls.isDragging = true;
                controls.previousMousePosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!controls.isDragging) return;
                
                const deltaMove = {
                    x: e.clientX - controls.previousMousePosition.x,
                    y: e.clientY - controls.previousMousePosition.y
                };
                
                // Rotate camera around target
                if (deltaMove.x !== 0 || deltaMove.y !== 0) {
                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            toRadians(-deltaMove.y * 0.5),
                            toRadians(-deltaMove.x * 0.5),
                            0,
                            'XYZ'
                        ));
                    
                    const cameraPosition = new THREE.Vector3().subVectors(
                        camera.position, controls.target
                    );
                    cameraPosition.applyQuaternion(deltaRotationQuaternion);
                    camera.position.copy(cameraPosition.add(controls.target));
                }
                
                controls.previousMousePosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                controls.isDragging = false;
            });
            
            // Zoom with mouse wheel
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const zoomDirection = e.deltaY > 0 ? 1 : -1;
                const cameraPosition = new THREE.Vector3().subVectors(
                    camera.position, controls.target
                );
                
                // Adjust distance based on zoom direction
                if (zoomDirection > 0) {
                    cameraPosition.multiplyScalar(controls.zoomSpeed);
                } else {
                    cameraPosition.divideScalar(controls.zoomSpeed);
                }
                
                camera.position.copy(cameraPosition.add(controls.target));
            });
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Convert degrees to radians
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Load OBJ file
        function loadOBJFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Show loading info
            document.getElementById('info').textContent = `Loading ${file.name}...`;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const contents = e.target.result;
                
                try {
                    // Parse OBJ file
                    const objData = parseOBJ(contents);
                    
                    // Check if we have vertices
                    if (objData.vertices.length === 0) {
                        throw new Error("No vertices found in OBJ file");
                    }
                    
                    // Create mesh from parsed data
                    const geometry = new THREE.BufferGeometry();
                    
                    // Add position attribute (vertices)
                    geometry.setAttribute(
                        'position', 
                        new THREE.Float32BufferAttribute(objData.vertices, 3)
                    );
                    
                    // Add normal attribute if available
                    if (objData.normals.length > 0) {
                        geometry.setAttribute(
                            'normal',
                            new THREE.Float32BufferAttribute(objData.normals, 3)
                        );
                    }
                    
                    // Compute vertex normals if not provided
                    if (objData.normals.length === 0) {
                        geometry.computeVertexNormals();
                    }
                    
                    // Create material and mesh
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xcccccc,
                        flatShading: false
                    });
                    
                    // Create the mesh at origin
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(0, 0, 0);
                    mesh.rotation.set(0, 0, 0);
                    mesh.scale.set(1, 1, 1);
                    
                    // Remove previous model if exists
                    if (currentModel) {
                        scene.remove(currentModel);
                    }
                    
                    // Reset the scene and camera
                    controls.target.set(0, 0, 0);
                    
                    // Add the mesh to the scene
                    scene.add(mesh);
                    currentModel = mesh;
                    
                    // Center and scale the model
                    // In some cases, we need a brief delay to ensure the geometry is initialized
                    setTimeout(() => {
                        // Center the vertices in the geometry itself
                        geometry.computeBoundingBox();
                        const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                        
                        // Move vertices to center the geometry at origin
                        const positionAttr = geometry.attributes.position;
                        for (let i = 0; i < positionAttr.count; i++) {
                            positionAttr.setXYZ(
                                i,
                                positionAttr.getX(i) - center.x,
                                positionAttr.getY(i) - center.y,
                                positionAttr.getZ(i) - center.z
                            );
                        }
                        positionAttr.needsUpdate = true;
                        
                        // Compute new bounding box after centering
                        geometry.computeBoundingBox();
                        const size = geometry.boundingBox.getSize(new THREE.Vector3());
                        
                        // Scale the model to a reasonable size
                        const maxDimension = Math.max(size.x, size.y, size.z);
                        if (maxDimension > 0) {
                            const scale = 5 / maxDimension;
                            mesh.scale.set(scale, scale, scale);
                        }
                        
                        // Update geometry
                        geometry.computeBoundingSphere();
                        
                        // Reset camera
                        resetCamera();
                        
                        // Update info
                        document.getElementById('info').textContent = `Loaded: ${file.name}`;
                    }, 100);
                } catch (error) {
                    document.getElementById('info').textContent = `Error: ${error.message}`;
                    console.error(error);
                }
            };
            
            reader.readAsText(file);
        }
        
        // Simple OBJ parser
        function parseOBJ(text) {
            const vertices = [];
            const normals = [];
            
            // Split the file by lines
            const lines = text.split('\n');
            
            // Temporary arrays to store data from the file
            const tempVertices = [];
            const tempNormals = [];
            
            // Process each line
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Skip empty lines and comments
                if (line === '' || line.startsWith('#')) continue;
                
                const parts = line.split(/\s+/);
                const prefix = parts[0];
                
                if (prefix === 'v') {
                    // Vertex
                    tempVertices.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                } else if (prefix === 'vn') {
                    // Vertex normal
                    tempNormals.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                } else if (prefix === 'f') {
                    // Face - only process if there are at least 3 vertices in the face
                    if (parts.length >= 4) {
                        processFace(parts, tempVertices, tempNormals, vertices, normals);
                    }
                }
            }
            
            return {
                vertices: vertices,
                normals: normals
            };
        }
        
        // Process face data
        function processFace(parts, tempVertices, tempNormals, vertices, normals) {
            // Handle different face formats
            // f v1 v2 v3
            // f v1/vt1 v2/vt2 v3/vt3
            // f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3
            // f v1//vn1 v2//vn2 v3//vn3
            
            // Create triangles for face (triangulation of polygon)
            for (let i = 1; i <= parts.length - 3; i++) {
                // Process each vertex of the triangle
                const v1 = parts[1];  // First vertex is always the same
                const v2 = parts[i + 1];
                const v3 = parts[i + 2];
                
                // Skip if any vertex is undefined
                if (!v1 || !v2 || !v3) continue;
                
                processVertex(v1, tempVertices, tempNormals, vertices, normals);
                processVertex(v2, tempVertices, tempNormals, vertices, normals);
                processVertex(v3, tempVertices, tempNormals, vertices, normals);
            }
        }
        
        // Process a single vertex reference in a face
        function processVertex(vertexData, tempVertices, tempNormals, vertices, normals) {
            if (!vertexData) return;
            
            const vertexParts = vertexData.split('/');
            
            // Get vertex index (OBJ indices are 1-based, so subtract 1)
            const vertexIndex = parseInt(vertexParts[0]) - 1;
            
            // Add the vertex coordinates
            if (vertexIndex >= 0 && vertexIndex * 3 + 2 < tempVertices.length) {
                vertices.push(
                    tempVertices[vertexIndex * 3],
                    tempVertices[vertexIndex * 3 + 1],
                    tempVertices[vertexIndex * 3 + 2]
                );
            }
            
            // If we have vertex normals, add them
            if (vertexParts.length > 2 && vertexParts[2] !== '') {
                const normalIndex = parseInt(vertexParts[2]) - 1;
                if (normalIndex >= 0 && normalIndex * 3 + 2 < tempNormals.length) {
                    normals.push(
                        tempNormals[normalIndex * 3],
                        tempNormals[normalIndex * 3 + 1],
                        tempNormals[normalIndex * 3 + 2]
                    );
                }
            }
        }
        
        // Center and scale the model to fit the scene
        function centerModel(model) {
            if (!model) return;
            
            // First completely reset the model's transformations
            model.position.set(0, 0, 0);
            model.rotation.set(0, 0, 0);
            model.scale.set(1, 1, 1);
            model.updateMatrixWorld(true);
            
            // Get the geometry and ensure it's centered
            const geometry = model.geometry;
            geometry.computeBoundingBox();
            
            // Create a bounding box
            const boundingBox = new THREE.Box3().setFromObject(model);
            const center = boundingBox.getCenter(new THREE.Vector3());
            const size = boundingBox.getSize(new THREE.Vector3());
            
            // Translate the geometry to center the model at world origin (0,0,0)
            geometry.translate(-center.x, -center.y, -center.z);
            
            // Scale the model to a reasonable size
            const maxDimension = Math.max(size.x, size.y, size.z);
            if (maxDimension > 0) {
                const scale = 5 / maxDimension;
                model.scale.set(scale, scale, scale);
            }
            
            // Force an update of the model's matrices
            model.updateMatrixWorld(true);
            
            // Display model info
            console.log('Model centered at origin. Size:', size);
            
            // Reset the camera position
            resetCamera();
        }
        
        // Reset camera to view the model properly
        function resetCamera() {
            if (currentModel) {
                // Set controls target to origin
                controls.target.set(0, 0, 0);
                
                // Get the size of the model for camera positioning
                const boundingBox = new THREE.Box3().setFromObject(currentModel);
                const size = boundingBox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                // Position camera at a 45-degree angle from the model
                camera.position.set(
                    maxDim * 1.5, 
                    maxDim * 1.5, 
                    maxDim * 1.5
                );
            } else {
                // Default position
                camera.position.set(0, 5, 10);
                controls.target.set(0, 0, 0);
            }
            
            camera.lookAt(controls.target);
        }
    </script>
</body>
</html>